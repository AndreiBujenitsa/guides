# list chronological history of things that happened
git reflog --all

#-----------------------------------------------------------------------------------
# How to find if a file has merge issue
git ls-files --unmerged
git diff # it will list diff with <<<< or >>>>
git ls-files --stage # notice number greater than zero close to end
git ls-files -t #notice M next to files yet to be merged
git mergetool # it will list files that need merging

# If a git merge is failing then use following technique to get more log info
git log --merge --left-right -p

# all the changes compared to ours can ben seen as
git diff --ours
#all the changes compared to theirs can be seen as
git diff --theirs


# Instead of --hard if you say --soft then all the changes will be removed from commit but
# those changed would be left staged.
# -----------------------------------------------------------------------------------




# A branch in Git is nothing more than a file in the .git/refs/heads/ directory that 
# contains the SHA-1 of the most recent commit of that branch.

# The index is found in .git/index and keeps track of file pathnames and corresponding blobs. Each time 
# you run commands such as git add, git rm, or git mv, Git updates the index with the new pathname 
# and blob information.

# Every single time something is added using git add, a new blob object is created at
# .git/objects. The path information about this blob at index. If user ends up not commiting
# the file after adding it then that blob stay there unless a cleanup action is done. That is how
# the number of blobs keep growing.

# A commit blob contains the name of tree that identifies it.

# A tree contains the information that maps a blob to a file. The tree itself is also stored
# at .git/objects .

# get list of all files in the index and their SHA1_HASH
git ls-files --stage

# compute the hash of a file. This hash value will be same as the hash value that is shown
# in git ls-files --stage
git hash-object Rakefile

# tracking changes after renaming a file
git mv foo1 foo2
git log foo2 # this will display all the log messages associated with foo2 but none with foo1
git log --follow foo2 #this will also display log messages associated with foo1 since foo1 and foo2 are same


# show all the diff between the current and master~2 version for all files under app directory
git diff master~2 master app


# caret is used to select a different parent. Given a commit, C, C^1 is the first parent,
# C^2 is the second parent, C^3 is the third parent

# tilde is used to go back before an ancestral parent and select a preceding generation. 
# Again, given the commit C, C~1 is the first parent, C~2 is the first grandparent, and 
# C~3 is the first great-grandparent.

# If you got your repository by cloning it, rather than initializing it, you should have a remote 
# branch of where you copied it from automatically added as origin by default.

# The tilde character, followed by a number, refers to the Nth genera- tion grandparent of that commit. 


# How to rename a file
git mv foo.txt bar.txt


# I have deleted a file using rm but not yet committed. How do I retrieve the file.
git co foo.txt

# checkout production branch of a project
git co -b production origin/production
git co --track -b production origin/production


# if you are getting merge error while rebasing then try interactive rebase and leave out the code 
# that is causing merge error.
git rebase -i master

# find longer version of the commit name
git rev-parse 54dedfd # 54dedfd8e1c5bc00f3dfabfd77f87286c04901f2

git rev-parse master

# rev-parse also works with tag names
git rev-prase tag_1 # 54dedfd8e1c5bc00f3dfabfd77f87286c04901f2

# add a file to a commit afterwards
git commit -m 'initial commit'
git add forgotten_file
git commit --amend

# merge the changes from staging to master branch
git co master # make sure that I am in master branch
git merge staging

# Revert a commit
# Note that this commit will appear in the log as the revert. In the log the original commit 
# and the reversal of that commit both will appear . Before the revert if there were 5 logs
# then after the revert there will be 6 logs.
git revert SHA1_HASH

# revert a commit but do not commit the revert commit
git revert --no-commit SHA1_HASH

# push local branch to github
git checkout -b experiment
git push origin experiment
git push --all # it pushes all the branches 


# improve performance
git gc
git fsck

# delete remote branch experiment
git push origin :experiment 

# squashed merge from staging. In squashed merge all the commits in staging would appear as
# single commit in master. Note that squash merge operations leaves the changes in working directory. 
# You need to commit the changes yourself.
git merge --squash staging

# diff between master branch and experiment branch
git diff --stat master experiment
git diff master experiment

git diff --cached

# delete a remote tag
git push origin :experiment 

gitk
gitk &

# figure out which branch is where
git log --pretty=oneline --graph --all


# find all the commits that have not been pushed to remote server
git cherry -v origin/master

# d921970^2 means “the second parent of d921970.” This syntax is only useful for merge 
# commits, which have more than one parent. The first parent is the branch you were on 
# when you merged, and the second is the commit on the branch that you merged in:
git show d921970^
git show d921970^2

# show the -1 version of admin_controller.rb
git show HEAD^:app/controllers/admin_controller.rb 

# if you want to replace the current content with the old one then do this
# note that there is no colon before app in this case
git checkout HEAD^ app/controllers/admin_controller.rb

# get the commit info about the 3rd grandparent
git rev-prase master~3

# show difference between current state and the last three commits
git diff master~3

# show difference between current state and master~3 for everything inside a directory
git diff master~3 app/models

# diff between two already committed commits
git diff master~10 master~3 --stat

# show difference between current state and the last three commits for one single file
git diff master~3 app/models/user.rb

# diff between two already committed commits for a single file
git diff master~10 master~3 app/models/user.rb

# show just the names of the files and status(added, modified, delete) between committs
git diff master~10 --name-status

# by default the diff shows 2 lines above and below. to change that number use this
git diff master~3 --unified=10

#--------------------------------------------------------------------------------------
git count-objects #36 objects

# make change to a single file
git add foo.txt
git count-objects #37 objects

# commit this change
git commit -m 'adding foo.txt' #39 objects
# increase in two objects because one of them is tree and other one is commit object
#--------------------------------------------------------------------------------------

# a branch in git is nothing more than a file in .git/refs/heads

# current branch
cat .git/HEAD
cat .git/config

# show the last commit info
git show master
git show master^


# cherry-picking is to apply one commit from source to the target
# in this case #ABCDEFG is the SHA-1 of the commit hash. One can
# stage multiple cherry-pickekd merges by adding the -n argument
git cherry-pick SHA1_HASH

# ls-tree accepts both commit and tree. if it is a commit then it shows
# the tree to which it belongs.
git ls-tree HEAD

# Any time you add a ^{tree} to any commit-ish, it resolves to its tree.
git ls-tree -r -t master^{tree} #displays current tree
git cat-file -p master^{tree}
git ls-tree master^{tree}
git ls-tree -r -t master^{tree} # -t makes also show the SHA1-s of subtrees

git pull == git fetch + git merge

git rebase --continue
git rebase --abort
git rebase --skip

git reflog

# rebase is useful not only for rebasing stuff from other branches but also squashing various
# commits into a single commit in a branch
git rebase -i HEAD~2 will let merge last two commits into a single commit.

# Also note that rebase provides and option to edit a commit where a single commit can be split
# into multiple commits.

# find all branches which are already merged in master
git co master
git branch --merged

# find all branches which are not yet merged in master
git co master
git branch --no-merged

# incase of merge if there is conflict and if I want to retain my copy of earth.txt and theirs
# copy of sun.txt then do this
gi co --ours earth.txt
git co --theirs sun.txt

# for all the files make my file take precedence
git co --ours *.*

# git does not allow to switch to a different branch is a file that is being tracked is modified. However
# -m option tells git to checkout the other branch and then merge with the local changes. In this way
# your current branch is left as it is and all the changes are in different branch.
git co -m staging

