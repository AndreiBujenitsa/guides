# bring all the changes from experiment branch in file app.js to master
git co experiment -- app.js

# other varieties
git checkout v1.2.3 -- filename         # tag v1.2.3
git checkout stable -- filename         # stable branch
git checkout origin/master -- filename  # upstream master
git checkout HEAD -- filename           # the version from the most recent commit
git checkout HEAD^ -- filename          # the version before the most recent commit

# remote tags and branches
>git ls-remote origin

# when a commit is done then HEAD is changed. One can manually change the HEAD like this
echo 5f1bc85745dcccce6121494fdd37658cb4ad441f > .git/refs/heads/master
git update-ref refs/heads/master 5f1bc857

# One can also manually change the branch from master to staging like this
.git/HEAD contains the reference to the current branch
.git/HEAD => refs/heads/production ( in production branch)
.git/HEAD => refs/heads/master ( in master branch)
git symbolic-ref HEAD refs/heads/staging


# reflog keeps track of every single object created. In case you have done something like
git reset --hard HEAD^ 
# accidentally and now you want to recover the last commit then 
# reflog will come in handy. That's all for now.
git reflog
git reflog --all

# error: The branch 'docs' is not an ancestor of your current HEAD.
# If you are sure you want to delete it, run 'git branch -D docs'
# you get this error because branch docs is not merged into the branch
# you are currently in . git is just trying to make sure that data is not lost
git branch -d docs

# find all the commits that are in staging but not in master
git cherry -v master staging

# revert everything
git reset --hard HEAD
git co -f

# revert a file in staging area
git co lab
# above command will fail if there is branch named lab. To enforce that lab is a file not 
# a branch do this
git co -- lab
git co ./lab

# Directed Acyclic Graph
# http://en.wikipedia.org/wiki/Directed_acyclic_graph

# remove a file from repository but keep it in the working directory
git rm --cached foo.txt

# better stash messages
git stash save 'writing test for user model'
git stash list # this list will have better messages

# diff with stashed items
git diff stash@{3}

# get rid of last commit
git reset --hard HEAD^

# get rid of last commit but leave all the changes in the working tree
# http://henrik.nyh.se/2009/02/git-reset-soft-as-stash-replacement-and-undo
git reset --soft HEAD^

# git does not allow to switch to a different branch is a file that is being tracked is modified. However
# -m option tells git to checkout the other branch and then merge with the local changes. In this way
# your current branch is left as it is and all the changes are in different branch.
git co -m staging

#-----------------------------------------------------------------------------------
# How to find if a file has merge issue
git ls-files --unmerged
git diff # it will list diff with <<<< or >>>>
git ls-files --stage # notice number greater than zero close to end
git ls-files -t #notice M next to files yet to be merged
git mergetool # it will list files that need merging

# If a git merge is failing then use following technique to get more log info
git log --merge --left-right -p

# all the changes compared to ours can ben seen as
git diff --ours
#all the changes compared to theirs can be seen as
git diff --theirs

# After a successful merge operation if you want to discard the merge operation then just use
# ORIG_HEAD to rollback changes. If you use HEAD then it will have no impact. Also note that
# reset --hard ORIG_HEAD should be the very first operation after the merge if you want to
# discard it.
git reset --hard ORIG_HEAD

# Instead of --hard if you say --soft then all the changes will be removed from commit but
# those changed would be left staged.
# -----------------------------------------------------------------------------------

# git creates new objects all the time. If a single line is added to a file then git will create a brand
# new object. However one can ask git to use previous object and to store only incremental difference.
# this is called packing.
git gc

# After the packing is done one can verify packing by running following command 
git verify-pack -v .git/objects/pack/pack-108ebf6abb50656e7aa5695314a47c3fc1e23f90.idx 

# git stores the 40 digit SHA1_HASH of the content. for foo.txt if the 40 char hash is
# 16ffbb1d57bfbf28a5b4da9ea71faf1c73b92272 then this content would be stored at
# .git/objects/16/ffbb1d57bfbf28a5b4da9ea71faf1c73b92272 . If you cat this file then
# you will see garbage. However you can  run below command to see the content
git cat-file -p 16ffbb1d57bfbf28a5b4da9ea71faf1c73b92272

# A branch in Git is nothing more than a file in the .git/refs/heads/ directory that 
# contains the SHA-1 of the most recent commit of that branch.

# The index is found in .git/index and keeps track of file pathnames and corresponding blobs. Each time 
# you run commands such as git add, git rm, or git mv, Git updates the index with the new pathname 
# and blob information.

# Every single time something is added using git add, a new blob object is created at
# .git/objects. The path information about this blob at index. If user ends up not commiting
# the file after adding it then that blob stay there unless a cleanup action is done. That is how
# the number of blobs keep growing.

# A commit blob contains the name of tree that identifies it.

# A tree contains the information that maps a blob to a file. The tree itself is also stored
# at .git/objects .

# get list of all files in the index and their SHA1_HASH
git ls-files --stage

# compute the hash of a file. This hash value will be same as the hash value that is shown
# in git ls-files --stage
git hash-object Rakefile

# tracking changes after renaming a file
git mv foo1 foo2
git log foo2 # this will display all the log messages associated with foo2 but none with foo1
git log --follow foo2 #this will also display log messages associated with foo1 since foo1 and foo2 are same


# show all the diff between the current and master~2 version for all files under app directory
git diff master~2 master app

# create a branch from one commit prior to master branch
git co -b staging master^

# When a commit occurs, Git records a snapshot of the index and places that snapshot 
# in the object store.  This snapshot does not contain a copy of every file and 
# directory in the index. Instead, Git compares the current state of the index to 
# the previous snapshot and so derives a list of affected files and directories. 
# Git creates new blobs for any file that has changed and new trees for any directory 
# that has changed, and it reuses any blob or tree object that has not changed.

# caret is used to select a different parent. Given a commit, C, C^1 is the first parent,
# C^2 is the second parent, C^3 is the third parent

# tilde is used to go back before an ancestral parent and select a preceding generation. 
# Again, given the commit C, C~1 is the first parent, C~2 is the first grandparent, and 
# C~3 is the first great-grandparent.

# If you got your repository by cloning it, rather than initializing it, you should have a remote 
# branch of where you copied it from automatically added as origin by default.

# The tilde character, followed by a number, refers to the Nth genera- tion grandparent of that commit. 

# HEAD is nothing else but refers to a commit. find out the commit HEAD points to
git show HEAD

# .gitignore file can be any directory
# if you want to ignore something local to youself then use .git/info/exclude

# How to get the status
git status

# How to do commit
git commit -m 'bug fixes for upload'

# Reset all the local changes
git reset --hard HEAD

# How do I revert a particular file which is not yet committed but has been locally changed
git co foo.txt

# How to rename a file
git mv foo.txt bar.txt

# add a new file called foo.txt and just commit this file
git add foo.txt
git commit -m 'adding foo.txt'

# add multiple files at the same time
git add foo.txt, bar.txt

# delete a file from git
git rm foo.txt

# I have deleted a file using rm but not yet committed. How do I retrieve the file.
git co foo.txt

# get list of all the files deleted using rm. Note it is not git rm
git ls-files --delete (-d)

# checkout production branch of a project
git co -b production origin/production
git co --track -b production origin/production

# create a new branch called experiment
git branch experiment 

# create a new branch called experiment and switch to that branch
git checkout -b experiment

# list all local branches and indicate which branch I am currently in
git branch 

# all branch info with last commit
git branch -v

# list all local and remote branches
git branch -a

# list only the remote branches ( does not include local branches)
git branch -r

# have some local changes that I want to throwaway and I want to get back to branch master
git co -f master

# show all the branches from which merge is yet to be done
git branch --no-merged

# delete the staging branch
git branch -d staging 

# show branches and display more info about them
git show-branch 

# show branches and display more info about them also lists directories from remote
git show-branch -a

# switch to the master branch
git checkout master 

# delete untracked files. 
# -d removes untracked directories in addition to untracked files.
# -f force
# -x do not use ignore rules. This allows removing all untracked files
# -X remove only files ignored by git
git clean -n -d

# push tags to remote server
git push origin --tags

# unstaging a staged file
git reset HEAD README

# show all the diff from last two log messages
git log -p -n 2

# git log in oneline
git log --oneline

# show all log messages for foo.txt
git log foo.txt

# view a remote file
git show origin/master:README

# show each line and the commit that last changed that line
git blame foo.txt

# show git blame only for certain number of lines
git blame -L 2,25 foo.txt

# info about a commit
git show SHA1_HASH

# if you are getting merge error while rebasing then try interactive rebase and leave out the code 
# that is causing merge error.
git rebase -i master

# find out if a commit is of type commit or tree
# -t is for type. it could be blob or tree
git cat-file -t ae850bd698b2b5dfbac 


# find longer version of the commit name
git rev-parse 54dedfd # 54dedfd8e1c5bc00f3dfabfd77f87286c04901f2

git rev-parse master

# rev-parse also works with tag names
git rev-prase tag_1 # 54dedfd8e1c5bc00f3dfabfd77f87286c04901f2

# add a file to a commit afterwards
git commit -m 'initial commit'
git add forgotten_file
git commit --amend

# global settings
git config --global user.name “Neeraj Singh”
git config --global user.email "neerajdotname@gmail.com" 

# use --unset option to remove a setting
git config --unset --global user.name

# just for this project
git config 
git config user.name 'John doe'
git config user.email 'john@doe.com'

# I want to change my user name and email address just for one single project. This change should
# not be global but just for one git project
cd demo
git config --list
git config -l
# Notice that user.name and user.email lines at the bottom of the list.
# this will supercede the user.email and user.email listed at the top
# of the list

cat ~/.gitconfig

# More information about a git project can also be seen by
cat .git/config

# log of changes made in staging branch over master branch
git log master..staging
git log --stat master..staging
# note that if staging is has some changes over master then git log the other way round does not work
git log staging..master #=> nil

# merge the changes from staging to master branch
git co master # make sure that I am in master branch
git merge staging

# Revert a commit
# Note that this commit will appear in the log as the revert. In the log the original commit 
# and the reversal of that commit both will appear . Before the revert if there were 5 logs
# then after the revert there will be 6 logs.
git revert SHA1_HASH

# revert a commit but do not commit the revert commit
git revert --no-commit SHA1_HASH

# push local branch to github
git checkout -b experiment
git push origin experiment
git push --all # it pushes all the branches 

# I have five commits I want to totally discard last two commits and start from third commit
# both the commits after the 3rd commit will be gone permanently. It is different from revert 
# where a reversal is another 
# commit. In this case the last two commits were just deleted. They are gone.
git log -n 5 #it will display all the five logs
git reset --hard SHA1_HASH (SHA1-HASH of the third commit)

# improve performance
git gc
git fsck

# delete remote branch experiment
git push origin :experiment 

# squashed merge from staging. In squashed merge all the commits in staging would appear as
# single commit in master. Note that squash merge operations leaves the changes in working directory. 
# You need to commit the changes yourself.
git merge --squash staging

# diff between master branch and experiment branch
git diff --stat master experiment
git diff master experiment

git diff --cached

# I have two files foo.txt and bar.txt
# I made changes to both the files
# now I added foo.txt to index ( git add foo.txt)
# I want to see all the changes from the HEAD. It should incluce the changes incurred in foo.txt and 
# bar.txt even though foo.txt has already been added to the index
git diff HEAD

git tag 'filter work done'
git push --tags

# create a tag for a commit which was done in the past
git tag -a v1.2 xxxxxxx

# tags list
git tag

# checkout a branch from a tag
git checkout -b v1.0

# delete a remote tag
git push origin :experiment 

# make a branch from a tag
git checkout -b <tag name>

gitk
gitk &

git log --stat production..master

# figure out which branch is where
git log --pretty=oneline --graph --all

# information about each commit and the number of files changed
git log --stat

# log information in one line
git log --shortstat 

# names of all files along with modified or added
git log --name-status 

# just the title
git log --pretty=short 

# one line log information
git log --pretty=oneline

git log --since="3 weeks"

git log --pretty=oneline --since="2007-12-01" --until='two months ago'

# do not list logs from merges 
git log --no-merges 

git log --pretty=oneline | wc -l

git log --no-merges --pretty=oneline | wc -l

# all the commits which had something to do with a file
git log --pretty=oneline db/schema.rb

# all the commits which had something to do with that file. limit the log to just 2 entries
git log -n 2 app/models/user.rb 

# lists all the diffs for every commit of that file
git log -p app/models/user.rb 

# looking for string ror_rocks in the diff. It was there in the file and then it got deleted.
git log -Sror_rocks
git log -Sror_rocks README

# find all the commits that have not been pushed to remote server
git cherry -v origin/master

# in the log show the diff
git log -p

# d921970^2 means “the second parent of d921970.” This syntax is only useful for merge 
# commits, which have more than one parent. The first parent is the branch you were on 
# when you merged, and the second is the commit on the branch that you merged in:
git show d921970^
git show d921970^2

# -n is for the dry run
git add -n -u 

# undo the last commit and keep the changes in the working tree
git reset --soft HEAD^

# show the -1 version of admin_controller.rb
git show HEAD^:app/controllers/admin_controller.rb 

# if you want to replace the current content with the old one then do this
# note that there is no colon before app in this case
git checkout HEAD^ app/controllers/admin_controller.rb


git remote
git remote -v
git remote show origin

# co-worked has put up a new branch called experiment. How do I pull that branch.
git checkout -b experiment origin/experiment

# get the commit info about the 3rd grandparent
git rev-prase master~3

# show difference between current state and the last three commits
git diff master~3

# show difference between current state and master~3 for everything inside a directory
git diff master~3 app/models

# diff between two already committed commits
git diff master~10 master~3 --stat

# show difference between current state and the last three commits for one single file
git diff master~3 app/models/user.rb

# diff between two already committed commits for a single file
git diff master~10 master~3 app/models/user.rb

# show just the names of the files and status(added, modified, delete) between committs
git diff master~10 --name-status

# by default the diff shows 2 lines above and below. to change that number use this
git diff master~3 --unified=10

#--------------------------------------------------------------------------------------
git count-objects #36 objects

# make change to a single file
git add foo.txt
git count-objects #37 objects

# commit this change
git commit -m 'adding foo.txt' #39 objects
# increase in two objects because one of them is tree and other one is commit object
#--------------------------------------------------------------------------------------

# a branch in git is nothing more than a file in .git/refs/heads

# current branch
cat .git/HEAD
cat .git/config

# show the last commit info
git show master
git show master^


# cherry-picking is to apply one commit from source to the target
# in this case #ABCDEFG is the SHA-1 of the commit hash. One can
# stage multiple cherry-pickekd merges by adding the -n argument
git cherry-pick SHA1_HASH

# ls-tree accepts both commit and tree. if it is a commit then it shows
# the tree to which it belongs.
git ls-tree HEAD

# Any time you add a ^{tree} to any commit-ish, it resolves to its tree.
git ls-tree -r -t master^{tree} #displays current tree
git cat-file -p master^{tree}
git ls-tree master^{tree}
git ls-tree -r -t master^{tree} # -t makes also show the SHA1-s of subtrees

git pull == git fetch + git merge

git rebase --continue
git rebase --abort
git rebase --skip

# make the commit name short
git log --abbrev-commit

# get the names of all commits for HEAD
git reflog

git stash
git stash list
git stash apply #applies the most recent one
git stash apply stash@{2}
git stash apply --index #applies changes to index

#create a branch off of stash and if branch is successfully created then stash is dropped.
#in this way one can work on stashed data in a branch
git stash branch filterWork

# rebase is useful not only for rebasing stuff from other branches but also squashing various
# commits into a single commit in a branch
git rebase -i HEAD~2 will let merge last two commits into a single commit.

# Also note that rebase provides and option to edit a commit where a single commit can be split
# into multiple commits.
