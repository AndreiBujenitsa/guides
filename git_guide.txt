git does not allow to switch to a different branch is a file that is being tracked is modified. However
-m option tells git to checkout the other branch and then merge with the local changes. In this way
your current branch is left as it is and all the changes are in different branch.
> git co -m staging

How to find if a file has merge issue
> git diff # it will list diff with <<<< or >>>>
> git ls-files --stage # notice number greater than zero close to end
> git mergetool # it will list files that need merging

If a git merge is failing then use following technique to get more log info
> git log --merge --left-right -p

when a merge conflict happens then find all unmerged files using git diff
> git diff
all the changes compared to ours can ben seen as
> git diff --ours
all the changes compared to theirs can be seen as
> git diff --theirs

git creates new objects all the time. If a single line is added to a file then git will create a brand
new object. However one can ask git to use previous object and to store only incremental difference.
this is called packing.
>git gc

After the packing is done one can verify packing by running following command 
>git verify-pack -v .git/objects/pack/pack-108ebf6abb50656e7aa5695314a47c3fc1e23f90.idx 


.git/HEAD contains the reference to the current branch
.git/HEAD => refs/heads/production ( in production branch)
.git/HEAD => refs/heads/master ( in master branch)
> git symbolic-ref HEAD


show current tree
> git cat-file -p master^{tree}

After a successful merge operation if you want to discard the merge operation then just do 
> git reset --hard ORIG_HEAD


git stores the 40 digit SHA1_HASH of the content. for foo.txt if the 40 char hash is
16ffbb1d57bfbf28a5b4da9ea71faf1c73b92272 then this content would be stored at
.git/objects/16/ffbb1d57bfbf28a5b4da9ea71faf1c73b92272 . If you cat this file then
you will see garbage. However you can  run below command to see the content
> git cat-file -p 16ffbb1d57bfbf28a5b4da9ea71faf1c73b92272

A branch in Git is nothing more than a file in the .git/refs/heads/ directory that 
contains the SHA-1 of the most recent commit of that branch.

Every single time something is added using git add, a new blob object is created at
.git/objects. The path information about this blob at index. If user ends up not commiting
the file after adding it then that blob stay there unless a cleanup action is done. That is how
the number of blobs keep growing.

A commit blob contains the name of tree that identifies it.

A tree contains the information that maps a blob to a file. The tree itself is also stored
at .git/objects .

get list of all files in the index and their SHA1_HASH
>git ls-files --stage

compute the hash of a file. This hash value will be same as the hash value that is shown
in git ls-files --stage
>git hash-object Rakefile

tracking changes after renaming a file
> git mv foo1 foo2
> git log foo2 # this will display all the log messages associated with foo2 but none with foo1
> git log --follow foo2 #this will also display log messages associated with foo1 since foo1 and foo2 are same


show all the diff between the current and master~2 version for all files under app directory
> git diff master~2 master app

create a branch from one commit prior to master branch
> git co -b staging master^


When a commit occurs, Git records a snapshot of the index and places that snapshot 
in the object store.  This snapshot does not contain a copy of every file and 
directory in the index. Instead, Git compares the current state of the index to 
the previous snapshot and so derives a list of affected files and directories. 
Git creates new blobs for any file that has changed and new trees for any directory 
that has changed, and it reuses any blob or tree object that has not changed.

caret is used to select a different parent. Given a commit, C, C^1 is the first parent,
C^2 is the second parent, C^3 is the third parent

tilde is used to go back before an ancestral parent and select a preceding generation. 
Again, given the commit C, C~1 is the first parent, C~2 is the first grandparent, and 
C~3 is the first great-grandparent.


> git log master

HEAD is nothing else but refers to a commit. find out the commit HEAD points to
> git show HEAD

# .gitignore file can be any directory
# if you want to ignore something local to youself then use .git/info/exclude

# How to get the status
> git status

# How to do commit
> git commit -m 'bug fixes for upload'

# Reset all the local changes
> git reset --hard HEAD

# How do I revert a particular file which is not yet committed but has been locally changed
> git co foo.txt

# How to rename a file
> git mv foo.txt bar.txt

# add a new file called foo.txt and just commit this file
> git add foo.txt
> git commit -m 'adding foo.txt'

# add multiple files at the same time
> git add foo.txt, bar.txt

# delete a file from git
> git rm foo.txt

# I have deleted a file using rm but not yet committed. How do I retrieve the file.
>git co foo.txt

# get list of all the files deleted using rm. Note it is not git rm
>git ls-files --delete (-d)

# checkout production branch of a project
>git co -b production origin/production

# create a new branch called experiment
> git branch experiment 

# show branches and display more info about them
> git show-branch 

# show branches and display more info about them also lists directories from remote
> git show-branch -a

# create a new branch called experiment and switch to that branch
> git checkout -b experiment

# list all local branches and indicate which branch I am currently in
> git branch 

# list all local and remote branches
> git branch -a

# list only the remote branches ( does not include local branches)
> git branch -r

# switch to the master branch
> git checkout master 

# delete untracked files. 
# -d removes untracked directories in addition to untracked files.
# -f force
# -x do not use ignore rules. This allows removing all untracked files
# -X remove only files ignored by git
>git clean -n -d

# show all the branches from which merge is yet to be done
>git branch --no-merged

# all branch info
>git branch

# all branch info with last commit
>git branch -v

# all branch info including remote branches
>git branch -a

# push tags to remote server
>git push origin --tags

# create a tag for a commit which was done in the past
>git tag -a v1.2 xxxxxxx

# unstaging a staged file
>git reset HEAD README

# show all the diff from last two log messages
> git log -p -n 2

# git log in oneline
>git log --oneline

# show all log messages for foo.txt
> git log foo.txt

# view a remote file
>git show origin/master:README

# show each line and the commit that last changed that line
> git blame foo.txt

# show git blame only for certain number of lines
>git blame -L 2,25 foo.txt

# info about a commit
>git show SHA1_HASH

# if you are getting merge error while rebasing then try interactive rebase and leave out the code 
that is causing merge error.
> git rebase -i master

# find out if a commit is of type commit or tree
# -t is for type. it could be blob or tree
>git cat-file -t ae850bd698b2b5dfbac 


# find longer version of the commit name
> git rev-parse 54dedfd
54dedfd8e1c5bc00f3dfabfd77f87286c04901f2

> git rev-parse master

# rev-parse also works with tag names
>git rev-prase version_1
54dedfd8e1c5bc00f3dfabfd77f87286c04901f2

# add a file to a commit afterwards
>git commit -m 'initial commit'
>git add forgotten_file
>git commit --amend

# global settings
>git config --global user.name “Neeraj Singh”
>git config --global user.email "neerajdotname@gmail.com" 

# use --unset option to remove a setting
>git config --unset --global user.name

# just for this project
> git config 
> git config user.name 'John doe'
> git config user.email 'john@doe.com'

# I want to change my user name and email address just for one single project. This change should
# not be global but just for one git project
> cd demo
> git config --list
# Notice that user.name and user.email lines at the bottom of the list.
# this will supercede the user.email and user.email listed at the top
# of the list

>cat ~/.gitconfig

# list the current configuration setting
>git config --list 

# More information about a git project can also be seen by
>cat .git/config

# log of changes made in staging branch over master branch
> git log master..staging
> git log --stat master..staging
# note that if staging is has some changes over master then git log the other way round does not work
> git log staging..master #=> nil


# merge the changes from staging to master branch
> git co master # make sure that I am in master branch
> git merge staging

# delete the staging branch
> git branch -d staging 

# Revert a commit
# Note that this commit will appear in the log as the revert. In the log the original commit 
# and the reversal of that commit both will appear . Before the revert if there were 5 logs
# then after the revert there will be 6 logs.
> git revert SHA1_HASH


# push local branch to github
> git checkout -b experiment
> git push origin experiment
> git push --all # it pushes all the branches 


# forgot to add a file to the last commit
> git add forgotten_file
> git commit --amend # now this file is in the last commit

# I have five commits I want to totally discard last two commits and start from third commit
# both the commits after the 3rd commit will be gone permanently. It is different from revert 
# where a reversal is another 
# commit. In this case the last two commits were just deleted. They are gone.
>git log -n 5 #it will display all the five logs
>git reset --hard SHA1_HASH (SHA1-HASH of the third commit)

# improve performance
> git gc
> git fsck

# delete remote branch experiment
>git push origin :experiment 

# squashed merge from staging. In squashed merge all the commits in staging would appear as
# single commit in master. Note that squash merge operations leaves the changes in working directory. 
# You need to commit the changes yourself.
git merge --squash staging

# diff between master branch and experiment branch
> git diff --stat master experiment
> git diff master experiment
> git diff --cached

# I have two files foo.txt and bar.txt
# I made changes to both the files
# now I added foo.txt to index ( git add foo.txt)
# I want to see all the changes from the HEAD. It should incluce the changes incurred in foo.txt and 
# bar.txt even though foo.txt has already been added to the index
> git diff HEAD

> git tag 'filter work done'
> git push --tags

# tags list
> git tag

# delete a remote tag
>git push origin :experiment 

# make a branch from a tag
>git checkout -b <tag name>

>gitk
>gitk &

>git log --stat production..master

# figure out which branch is where
>git log --pretty=oneline --graph --all

# information about each commit and the number of files changed
> git log --stat

# log information in one line
>git log --shortstat 

# names of all files along with modified or added
>git log --name-status 

# just the title
>git log --pretty=short 

# one line log information
>git log --pretty=oneline

>git log --since="3 weeks"

>git log --pretty=oneline --since="2007-12-01" --until='two months ago'

# do not list logs from merges 
>git log --no-merges 

>git log --pretty=oneline | wc -l

>git log --no-merges --pretty=oneline | wc -l

# all the commits which had something to do with a file
>git log --pretty=oneline db/schema.rb

# all the commits which had something to do with that file. limit the log to just 2 entries
>git log -n 2 app/models/user.rb 

# lists all the diffs for every commit of that file
>git log -p app/models/user.rb 


# looking for string ror_rocks in the diff. It was there in the file and then it got deleted.
>git log -Sror_rocks
>git log -Sror_rocks README

# find all the commits that have not been pushed to remote server
git cherry -v origin/master

>git tag

# have some local changes that I want to throwaway and I want to get back to branch master
git co -f master

in the log show the diff
>git log -p

>git remote show origin

d921970^2 means “the second parent of d921970.” This syntax is only useful for merge 
commits, which have more than one parent. The first parent is the branch you were on 
when you merged, and the second is the commit on the branch that you merged in:
>git show d921970^
>git show d921970^2


-n is for the dry run
>git add -n -u 

>git ls-tree -r -t master^{tree}

undo the last commit and keep the changes in the working tree
>git reset --soft HEAD^


# show the -1 version of admin_controller.rb
> git show HEAD^:app/controllers/admin_controller.rb 

# if you want to replace the current content with the old one then do this
# note that there is no colon before app in this case
> git checkout HEAD^ app/controllers/admin_controller.rb

>git remote show origin

>git remote -v

>git ls-remote origin

>git ls-files -s

The index is found in .git/index and keeps track of file pathnames and corresponding blobs. Each time 
you run commands such as git add, git rm, or git mv, Git updates the index with the new pathname 
and blob information.

>find .git/objects

# co-worked has put up a new branch called experiment. How do I pull that branch.
> git checkout -b experiment origin/experiment

# get the commit info about the 3rd grandparent
>git rev-prase master~3

# show difference between current state and the last three commits
>git diff master~3

# show difference between current state and master~3 for everything inside a directory
>git diff master~3 app/models

# diff between two already committed commits
>git diff master~10 master~3 --stat

# show difference between current state and the last three commits for one single file
>git diff master~3 app/models/user.rb

# diff between two already committed commits for a single file
>git diff master~10 master~3 app/models/user.rb

# show just the names of the files and status(added, modified, delete) between committs
>git diff master~10 --name-status

# by default the diff shows 2 lines above and below. to change that number use this
>git diff master~3 --unified=10

--------------------------------------------------------------------------------------
> git count-objects
36 objects

# make change to a single file
> git add foo.txt
> git count-objects
37 objects

# commit this change
> git commit -m 'adding foo.txt'
39 objects
# increase in two objects because one of them is tree and other one is commit object
--------------------------------------------------------------------------------------

# You want to find out if this git repository has been linked to github or not
# if remote has not been setup then the output will be empty
> git remote
origin


# a branch in git is nothing more than a file in .git/refs/heads

# current branch
> cat .git/HEAD
> cat .git/config

# show the last commit info
> git show master
> git show master^


# showing tree
git ls-tree master^{tree}
git ls-tree -r -t master^{tree} # -t makes also show the SHA1-s of subtrees


#########################################################
git cherry. This does exactly what we want: tells us which commits aren’t in the branch 
specified. So if I was on the master branch and I ran:

$ git cherry -v master 42-adding-replies
+ a4d0f79fccbbc12a53e8f0e5c2a4ef960ad69ba2 Adding posts in
+ 7e71afd1faf36f17a0ff506e63cd2ca51496dad3 Revert "Adding posts in"
+ 5e815ece05d8813354e60ca1affb8cdb8c5d78fc Adding the right model
+ 956f4cec5684544066a0d261ff8ac80aff7a57ea Cleaning up model
+ 6c6cdb4342ed935f8fbd38f48f51dec469dd1823 Who needs tests?
+ c3481fd0d6279f5bd45c455b915e0b4b1c0d8909 Wrapping this up. Ship it.


So what we just did was asked Git what’s not in master that’s in 42-adding-replies branch. Just like in the images above it’s simple to see what needs to get merged in still. The -v option will print out the commit message along with the SHA hash so it’s easier to figure out what exactly you’re looking at. This command also takes in a third, optional argument for picking a starting point or limit. So, if we wanted to just check everything after commit 7e71af, you’d get this:

$ git cherry -v master 42-adding-replies 7e71af
+ 5e815ece05d8813354e60ca1affb8cdb8c5d78fc Adding the right model
+ 956f4cec5684544066a0d261ff8ac80aff7a57ea Cleaning up model
+ 6c6cdb4342ed935f8fbd38f48f51dec469dd1823 Who needs tests?
+ c3481fd0d6279f5bd45c455b915e0b4b1c0d8909 Wrapping this up. Ship it.

As you can see, that skipped the first two commits in our topic branch. If you wanted to check what hasn’t been merged into an upstream branch when not actually on the upstream branch, it’s a little simpler:

$ git checkout 42-adding-replies
$ git cherry master
+ a4d0f79fccbbc12a53e8f0e5c2a4ef960ad69ba2
+ 7e71afd1faf36f17a0ff506e63cd2ca51496dad3
+ 5e815ece05d8813354e60ca1affb8cdb8c5d78fc
+ 956f4cec5684544066a0d261ff8ac80aff7a57ea
+ 6c6cdb4342ed935f8fbd38f48f51dec469dd1823
+ c3481fd0d6279f5bd45c455b915e0b4b1c0d8909
#########################################################

# cherry-picking to apply one commit from source to the target
# in this case #ABCDEFG is the SHA-1 of the commit hash. One can
# stage multiple cherry-pickekd merges by adding the -n argument
git cherry-pick SHA1_HASH
